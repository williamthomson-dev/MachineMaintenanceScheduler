@page "/maintenanceScheduler"

@using System.Globalization
@using MachineMaintenanceScheduler.Features.MaintenanceScheduling.Components
@using MachineMaintenanceScheduler.Features.MaintenanceScheduling.Interfaces
@using MachineMaintenanceScheduler.Features.MaintenanceScheduling.Models
@using MachineMaintenanceScheduler.Features.MaintenanceScheduling.Services
@using MachineMaintenanceScheduler.Features.Machines.Interfaces
@using MachineMaintenanceScheduler.Shared.Components
@using MachineMaintenanceScheduler.Shared.Modals
@using MachineMaintenanceScheduler.Shared.Services
@attribute [StreamRendering]
@rendermode InteractiveServer

<h3>Planned Maintenance Schedule</h3>

<div class="alert alert-info mt-3">
    <strong>Note:</strong> Only machines with an assigned <em>maintenance rule</em> and <em>required skill</em> can be scheduled.
    A technician must also have a matching skill to be assigned to the task.
</div>

@if (plannedTasks is null || !plannedTasks.Any())
{
    <p>No machines require maintenance at this time.</p>
}
else
{

    <button class="btn btn-success mt-4" @onclick="ConfirmSchedule">Confirm and Apply Schedule</button>

    @foreach (var group in groupedTasks)
    {
        <ScheduledDayGroup ScheduledDate="group.Key" Tasks="group.ToList()" />
    }
}

<ToastMessageModal IsVisible="@isToastVisible"
                   Message="@toastMessage"
                   ToastType="ToastType.Warning" />

@code {
    private List<PlannedMaintenanceTask>? plannedTasks;
    private bool isToastVisible;
    private string toastMessage = "";

    [Inject] IMaintenanceScheduler _scheduler { get; set; } = default!;
    [Inject] IMachineService _machineService { get; set; } = default!;
    [Inject] IToastService _toastService { get; set; } = default!;

    private List<IGrouping<DateTime, PlannedMaintenanceTask>> groupedTasks = new();

    protected override async Task OnInitializedAsync()
    {
        plannedTasks = await _scheduler.GeneratePlannedTasksAsync();

        if (plannedTasks != null)
        {
            groupedTasks = plannedTasks
                .GroupBy(t => t.MaintenanceScheduledDate.Date)
                .OrderBy(g => g.Key)
                .ToList();
        }
    }

    private async Task ConfirmSchedule()
    {
        if (plannedTasks is null) return;

        foreach (var task in plannedTasks)
        {
            var machine = await _machineService.GetMachineByIdAsync(task.MachineId);
            if (machine is null) continue;

            machine.ScheduledDate = task.MaintenanceScheduledDate;
            await _machineService.UpdateMachineAsync(machine);
        }

        _toastService.ShowToastMessage("Maintenance schedule confirmed and applied.");
    }
}
